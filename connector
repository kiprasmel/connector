#!/bin/bash
# connector - Universal WireGuard VPS-WSL management tool
# Manages registration and approval of WSL machines to a central VPS

set -e

VERSION="1.0.0"
REGISTRY_DIR="/var/lib/wsl-registry"
WG_CONFIG_DIR="/etc/wireguard"
WSL_CONNECTOR_DIR="${HOME}/.config/wsl-connector"
WG_PORT="51820"
WG_INTERFACE="wg0"
VPS_WG_IP="10.0.0.1"
WG_SUBNET="10.0.0.0/24"
STAGING_USER="connector"

# Helper functions
log_info() { echo "[INFO] $*"; }
log_success() { echo "[SUCCESS] $*"; }
log_warn() { echo "[WARN] $*"; }
log_error() { echo "[ERROR] $*" >&2; }

require_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "This command must be run as root"
        exit 1
    fi
}

require_package() {
    if ! command -v "$1" &> /dev/null; then
        log_error "Required package '$1' is not installed"
        exit 1
    fi
}

is_vps() {
    [ -d "$REGISTRY_DIR" ]
}

is_arch() {
    [ -f /etc/arch-release ]
}

generate_machine_id() {
    echo "wsl-$(head /dev/urandom | tr -dc a-z0-9 | head -c 8)"
}

get_next_ip() {
    local max_ip=1
    if [ -d "$REGISTRY_DIR/approved" ]; then
        for file in "$REGISTRY_DIR/approved"/*.json; do
            [ -f "$file" ] || continue
            local ip=$(jq -r '.wg_ip' "$file" 2>/dev/null | cut -d'.' -f4)
            if [ -n "$ip" ] && [ "$ip" -gt "$max_ip" ]; then
                max_ip=$ip
            fi
        done
    fi
    echo "10.0.0.$((max_ip + 1))"
}

# VPS-INIT: Initialize VPS as WireGuard server
cmd_vps_init() {
    log_info "Initializing VPS as WireGuard server..."
    require_root

    # Detect package manager
    if command -v apt &> /dev/null; then
        PKG_INSTALL="apt update && apt install -y"
    elif command -v yum &> /dev/null; then
        PKG_INSTALL="yum install -y"
    elif command -v pacman &> /dev/null; then
        PKG_INSTALL="pacman -Sy --noconfirm"
    else
        log_error "No supported package manager found (apt/yum/pacman)"
        exit 1
    fi

    # Install required packages
    log_info "Installing required packages..."
    eval "$PKG_INSTALL wireguard-tools jq openssh-server"

    # Generate WireGuard server keys
    log_info "Generating WireGuard server keys..."
    mkdir -p "$WG_CONFIG_DIR"
    wg genkey | tee "$WG_CONFIG_DIR/server_private.key" | wg pubkey > "$WG_CONFIG_DIR/server_public.key"
    chmod 600 "$WG_CONFIG_DIR/server_private.key"
    local server_private=$(cat "$WG_CONFIG_DIR/server_private.key")
    local server_public=$(cat "$WG_CONFIG_DIR/server_public.key")

    # Create registry directories
    log_info "Creating registry directories..."
    mkdir -p "$REGISTRY_DIR"/{pending,approved,configs,revoked}
    
    # Verify directories were created
    for dir in pending approved configs revoked; do
        if [ ! -d "$REGISTRY_DIR/$dir" ]; then
            log_error "Failed to create directory: $REGISTRY_DIR/$dir"
            exit 1
        fi
    done
    
    # Set initial ownership (will be refined after user creation)
    chown -R root:root "$REGISTRY_DIR"
    chmod 755 "$REGISTRY_DIR"

    # Clean up old scponly script if it exists
    if [ -f /usr/bin/scponly ]; then
        log_info "Removing old scponly script..."
        rm -f /usr/bin/scponly
        sed -i '\|^/usr/bin/scponly$|d' /etc/shells 2>/dev/null || true
    fi
    
    # Create staging user (simple approach - let file permissions do the work)
    log_info "Creating staging user with restricted access..."
    read -sp "Enter new password for staging user '$STAGING_USER': " staging_password
    echo
    
    if id "$STAGING_USER" &>/dev/null; then
        log_warn "User $STAGING_USER already exists, updating..."
        echo "$STAGING_USER:$staging_password" | chpasswd
        # Ensure shell is /bin/bash (not old scponly)
        usermod -s /bin/bash "$STAGING_USER"
    else
        # Create user with /bin/bash (SCP will work fine, interactive login blocked by SSH config)
        useradd -m -s /bin/bash "$STAGING_USER"
        echo "$STAGING_USER:$staging_password" | chpasswd
    fi
    
    log_success "Created user $STAGING_USER"

    # Set final permissions for registry directories
    log_info "Setting registry directory permissions..."
    
    # pending: writable by staging user (for uploads)
    chown "$STAGING_USER:$STAGING_USER" "$REGISTRY_DIR/pending"
    chmod 755 "$REGISTRY_DIR/pending"  # rwxr-xr-x
    
    # configs: readable by staging user (for downloads)  
    chown root:root "$REGISTRY_DIR/configs"
    chmod 755 "$REGISTRY_DIR/configs"  # rwxr-xr-x
    
    # approved and revoked: root only
    chown root:root "$REGISTRY_DIR"/{approved,revoked}
    chmod 700 "$REGISTRY_DIR"/{approved,revoked}  # rwx------
    
    log_success "Registry directories configured with proper permissions"
    
    # Configure SSH for staging user with restrictions
    log_info "Configuring SSH with restricted access for staging user..."
    
    # Backup sshd_config
    cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
    
    # Remove any existing Match User configuration for staging user
    sed -i "/^Match User $STAGING_USER/,/^Match /d" /etc/ssh/sshd_config
    sed -i "/^Match User $STAGING_USER/,\$d" /etc/ssh/sshd_config
    
    # Simple SSH config - just enable password auth and block interactive login
    cat >> /etc/ssh/sshd_config <<EOF

# Restricted access for staging user (connector tool)
# File permissions control what they can access
Match User $STAGING_USER
    PasswordAuthentication yes
    PermitTTY no
    X11Forwarding no
    AllowTcpForwarding no
    PermitTunnel no
    AllowAgentForwarding no
EOF

    # Create a simple SCP-only wrapper script
    cat > /usr/bin/scponly <<'SCPONLY'
#!/bin/bash
# SCP-only restricted shell for staging user
# Only allows scp file transfers, no interactive commands

# Log the command for debugging (optional, can be disabled in production)
# echo "DEBUG: SSH_ORIGINAL_COMMAND=$SSH_ORIGINAL_COMMAND" >> /tmp/scponly.log

# Extract the actual path from the SCP command
# SCP commands come in two forms:
# - Upload: scp [options] -t /path/to/file
# - Download: scp [options] -f /path/to/file

if [[ -z "$SSH_ORIGINAL_COMMAND" ]]; then
    echo "Access denied: No command specified" >&2
    exit 1
fi

# Check if this is an SCP command
if [[ ! "$SSH_ORIGINAL_COMMAND" =~ ^scp[[:space:]] ]]; then
    echo "Access denied: Only SCP file transfers are allowed" >&2
    exit 1
fi

# Extract the target path (last argument after -t or -f flag)
if [[ "$SSH_ORIGINAL_COMMAND" =~ -t[[:space:]]+(/[^[:space:]]+) ]] || \
   [[ "$SSH_ORIGINAL_COMMAND" =~ -f[[:space:]]+(/[^[:space:]]+) ]]; then
    target_path="${BASH_REMATCH[1]}"
    
    # Check if the path is in allowed directories
    if [[ "$target_path" == /var/lib/wsl-registry/pending/* ]]; then
        # Allow uploads to pending directory
        exec $SSH_ORIGINAL_COMMAND
    elif [[ "$target_path" == /var/lib/wsl-registry/configs/* ]]; then
        # Allow downloads from configs directory
        exec $SSH_ORIGINAL_COMMAND
    else
        echo "Access denied: Path '$target_path' is not in allowed directories" >&2
        echo "Allowed paths: /var/lib/wsl-registry/pending/* (upload), /var/lib/wsl-registry/configs/* (download)" >&2
        exit 1
    fi
else
    echo "Access denied: Invalid SCP command format" >&2
    echo "Command received: $SSH_ORIGINAL_COMMAND" >&2
    exit 1
fi
SCPONLY
    
    chmod +x /usr/bin/scponly
    log_success "Created restricted SCP-only shell"
    
    # Test SSH configuration
    if sshd -t; then
        log_success "SSH configuration is valid"
    else
        log_error "SSH configuration has errors. Restoring backup..."
        cp /etc/ssh/sshd_config.backup /etc/ssh/sshd_config
        exit 1
    fi
    
    # Restart SSH service
    if systemctl restart sshd 2>/dev/null || systemctl restart ssh 2>/dev/null || service ssh restart 2>/dev/null; then
        log_success "SSH service restarted"
    else
        log_warn "Could not restart SSH service automatically. Please restart manually: sudo systemctl restart sshd"
    fi

    # Create WireGuard server config
    log_info "Creating WireGuard server configuration..."
    cat > "$WG_CONFIG_DIR/$WG_INTERFACE.conf" <<EOF
[Interface]
Address = $VPS_WG_IP/24
ListenPort = $WG_PORT
PrivateKey = $server_private
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Peers will be added below this line
EOF

    chmod 600 "$WG_CONFIG_DIR/$WG_INTERFACE.conf"

    # Enable IP forwarding
    log_info "Enabling IP forwarding..."
    echo "net.ipv4.ip_forward=1" > /etc/sysctl.d/99-wireguard.conf
    sysctl -p /etc/sysctl.d/99-wireguard.conf

    # Configure firewall
    log_info "Configuring firewall..."
    if command -v ufw &> /dev/null; then
        # Allow WireGuard
        ufw allow $WG_PORT/udp comment 'WireGuard'
        # Allow SSH from WireGuard network only (will be added after WireGuard is up)
        log_success "UFW rules configured"
    elif command -v firewall-cmd &> /dev/null; then
        firewall-cmd --permanent --add-port=$WG_PORT/udp
        firewall-cmd --reload
        log_success "Firewalld rules configured"
    else
        log_warn "No firewall manager detected. Manually configure:"
        log_warn "  - Allow UDP port $WG_PORT (WireGuard)"
    fi
    
    log_info "VPS security configured"
    log_info "Note: VPS SSH remains accessible for admin access"
    log_info "WSL machines will only be accessible via WireGuard"

    # Enable and start WireGuard
    log_info "Enabling WireGuard service..."
    systemctl enable wg-quick@$WG_INTERFACE
    systemctl start wg-quick@$WG_INTERFACE

    # Get VPS public IP
    local vps_ip=$(curl -s ifconfig.me || echo "YOUR_VPS_IP")
    
    # Detect SSH port
    local ssh_port=$(grep -E "^Port " /etc/ssh/sshd_config | awk '{print $2}' || echo "22")
    ssh_port=${ssh_port:-22}  # Default to 22 if not found
    
    # Build register command
    local register_cmd="./connector register $vps_ip"
    if [ "$ssh_port" != "22" ]; then
        register_cmd="$register_cmd -p $ssh_port"
    fi

    log_success "VPS initialization complete!"
    echo
    echo "=================================================="
    echo "Server Details:"
    echo "  VPS Public IP: $vps_ip"
    echo "  SSH Port: $ssh_port"
    echo "  WireGuard IP: $VPS_WG_IP"
    echo "  WireGuard Port: $WG_PORT"
    echo "  Server Public Key: $server_public"
    echo
    echo "Staging User:"
    echo "  Username: $STAGING_USER"
    echo "  Password: $staging_password"
    echo
    echo "Security Configuration:"
    echo "  - Password auth enabled ONLY for staging user"
    echo "  - Interactive shell disabled for staging user"
    echo "  - Staging user limited to SCP file transfers"
    echo "  - Access restricted to registry directories only"
    echo "  - WSL machines will use key-based authentication only"
    echo "  - SSH backup saved at: /etc/ssh/sshd_config.backup"
    echo
    echo "Next Steps:"
    echo "  1. On WSL machines, run: $register_cmd"
    echo "  2. Approve machines with: ./connector approve"
    echo "=================================================="
}

# REGISTER: Register machine to VPS
cmd_register() {
    local reg_type=""
    local vps_ip=""
    local staging_password=""
    local ssh_port="22"
    
    # First argument must be type
    if [ -z "$1" ]; then
        log_error "Usage: connector register <provider|consumer> <vps-ip> [staging-password] [-p|--port <port>]"
        log_error "Example: connector register provider 203.0.113.1 -p 2222"
        log_error "Example: connector register consumer 203.0.113.1 -p 2222"
        exit 1
    fi
    
    reg_type="$1"
    shift
    
    # Validate type
    if [ "$reg_type" != "provider" ] && [ "$reg_type" != "consumer" ]; then
        log_error "Invalid registration type: $reg_type"
        log_error "Type must be either 'provider' or 'consumer'"
        log_error "Usage: connector register <provider|consumer> <vps-ip> [staging-password] [-p|--port <port>]"
        exit 1
    fi
    
    # Parse remaining arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--port)
                ssh_port="$2"
                shift 2
                ;;
            *)
                if [ -z "$vps_ip" ]; then
                    vps_ip="$1"
                elif [ -z "$staging_password" ]; then
                    staging_password="$1"
                fi
                shift
                ;;
        esac
    done

    if [ -z "$vps_ip" ]; then
        log_error "Usage: connector register <provider|consumer> <vps-ip> [staging-password] [-p|--port <port>]"
        log_error "Example: connector register provider 203.0.113.1 -p 2222"
        log_error "Example: connector register consumer 203.0.113.1 -p 2222"
        exit 1
    fi

    log_info "Registering $reg_type machine to VPS $vps_ip..."

    # Install dependencies on Arch Linux
    if is_arch; then
        log_info "Detected Arch Linux, installing dependencies..."
        if ! command -v wg &> /dev/null || ! command -v ssh &> /dev/null; then
            sudo pacman -Sy --noconfirm wireguard-tools openssh
        fi
    else
        log_warn "Non-Arch Linux detected. Ensure wireguard-tools and openssh are installed."
    fi

    # Create local config directory
    mkdir -p "$WSL_CONNECTOR_DIR"
    chmod 700 "$WSL_CONNECTOR_DIR"

    # Generate machine ID
    local machine_id=$(generate_machine_id)
    echo "$machine_id" > "$WSL_CONNECTOR_DIR/machine-id"
    log_success "Generated machine ID: $machine_id"

    # Generate WireGuard keys
    log_info "Generating WireGuard keypair..."
    local wg_private=$(wg genkey)
    local wg_public=$(echo "$wg_private" | wg pubkey)
    echo "$wg_private" > "$WSL_CONNECTOR_DIR/wg-private-key"
    chmod 600 "$WSL_CONNECTOR_DIR/wg-private-key"

    # Generate SSH key if not exists
    local ssh_key="$HOME/.ssh/wsl-to-vps"
    if [ ! -f "$ssh_key" ]; then
        log_info "Generating SSH keypair..."
        ssh-keygen -t ed25519 -f "$ssh_key" -N "" -C "$machine_id@wsl"
    fi
    local ssh_pubkey=$(cat "$ssh_key.pub")

    # Collect machine info
    local hostname=$(cat /etc/hostname 2>/dev/null || echo "${HOSTNAME:-unknown}")
    local username=$(whoami)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Create registration JSON
    local reg_json=$(cat <<EOF
{
  "machine_id": "$machine_id",
  "type": "$reg_type",
  "timestamp": "$timestamp",
  "hostname": "$hostname",
  "username": "$username",
  "wg_pubkey": "$wg_public",
  "ssh_pubkey": "$ssh_pubkey",
  "request_note": "Machine registration ($reg_type)"
}
EOF
)

    # Save registration locally
    echo "$reg_json" > "$WSL_CONNECTOR_DIR/registration.json"
    
    # Save VPS connection info for finalize
    cat > "$WSL_CONNECTOR_DIR/vps-info" <<EOF
VPS_IP=$vps_ip
SSH_PORT=$ssh_port
EOF
    chmod 600 "$WSL_CONNECTOR_DIR/vps-info"

    # Upload registration to VPS
    log_info "Uploading registration to VPS (port $ssh_port)..."
    local temp_file="/tmp/${machine_id}.json"
    echo "$reg_json" > "$temp_file"
    
    # Check if sshpass is available
    if command -v sshpass &> /dev/null; then
        # Prompt for staging password if not provided and sshpass is available
        if [ -z "$staging_password" ]; then
            read -sp "Enter staging user password: " staging_password
            echo
        fi
        
        log_info "Using sshpass for authentication..."
        local scp_output
        if scp_output=$(sshpass -p "$staging_password" scp -P "$ssh_port" -o StrictHostKeyChecking=no -o ConnectTimeout=10 "$temp_file" "${STAGING_USER}@${vps_ip}:${REGISTRY_DIR}/pending/${machine_id}.json" 2>&1); then
            rm "$temp_file"
            log_success "Registration uploaded successfully!"
        else
            log_error "Upload failed. Error details:"
            echo "$scp_output" >&2
            log_error "Check VPS IP, port ($ssh_port), password, and network connectivity."
            rm "$temp_file"
            exit 1
        fi
    else
        # Fallback to interactive SCP
        log_info "sshpass not installed. Using interactive SCP..."
        log_info "You will be prompted for the staging user password."
        
        local scp_output
        if scp_output=$(scp -P "$ssh_port" -o StrictHostKeyChecking=no -o ConnectTimeout=10 "$temp_file" "${STAGING_USER}@${vps_ip}:${REGISTRY_DIR}/pending/${machine_id}.json" 2>&1); then
            rm "$temp_file"
            log_success "Registration uploaded successfully!"
        else
            log_error "Upload failed. Error details:"
            echo "$scp_output" >&2
            log_error "Check VPS IP, port ($ssh_port), and network connectivity."
            rm "$temp_file"
            exit 1
        fi
    fi

    echo
    echo "=================================================="
    echo "Registration Complete!"
    echo
    echo "  Machine ID: $machine_id"
    echo "  Type: $reg_type"
    echo "  Status: Waiting for approval"
    echo
    echo "Next Steps:"
    echo "  1. Contact VPS admin to approve this machine"
    echo "  2. Provide them with machine ID: $machine_id"
    echo "  3. After approval, run: ./connector finalize $reg_type $machine_id"
    echo "=================================================="
}

# APPROVE: Approve pending WSL machine
cmd_approve() {
    local machine_id="$1"
    require_root

    if ! is_vps; then
        log_error "This command must be run on the VPS"
        exit 1
    fi

    require_package jq

    # List pending registrations if no machine_id provided
    if [ -z "$machine_id" ]; then
        log_info "Pending registrations:"
        echo
        local count=0
        for file in "$REGISTRY_DIR/pending"/*.json; do
            [ -f "$file" ] || continue
            count=$((count + 1))
            local mid=$(basename "$file" .json)
            local hostname=$(jq -r '.hostname' "$file")
            local username=$(jq -r '.username' "$file")
            local timestamp=$(jq -r '.timestamp' "$file")
            local reg_type=$(jq -r '.type // "provider"' "$file")
            local type_label="COMPUTE PROVIDER"
            if [ "$reg_type" = "consumer" ]; then
                type_label="COMPUTE CONSUMER"
            fi
            echo "  [$count] $mid ($type_label)"
            echo "      Host: $hostname | User: $username | Time: $timestamp"
            echo
        done

        if [ $count -eq 0 ]; then
            log_warn "No pending registrations found"
            exit 0
        fi

        read -p "Enter machine ID to approve: " machine_id
    fi

    # Validate registration exists
    local reg_file="$REGISTRY_DIR/pending/${machine_id}.json"
    if [ ! -f "$reg_file" ]; then
        log_error "Registration not found: $machine_id"
        exit 1
    fi

    log_info "Approving machine: $machine_id"

    # Parse registration
    local hostname=$(jq -r '.hostname' "$reg_file")
    local username=$(jq -r '.username' "$reg_file")
    local wg_pubkey=$(jq -r '.wg_pubkey' "$reg_file")
    local ssh_pubkey=$(jq -r '.ssh_pubkey' "$reg_file")
    local reg_type=$(jq -r '.type // "provider"' "$reg_file")

    # Allocate IP
    local client_ip=$(get_next_ip)
    log_success "Assigned IP: $client_ip"

    # Add peer to WireGuard config
    log_info "Adding WireGuard peer..."
    cat >> "$WG_CONFIG_DIR/$WG_INTERFACE.conf" <<EOF

# $machine_id ($hostname)
[Peer]
PublicKey = $wg_pubkey
AllowedIPs = $client_ip/32
EOF

    # Reload WireGuard
    wg syncconf "$WG_INTERFACE" <(wg-quick strip "$WG_INTERFACE")
    log_success "WireGuard configuration updated"

    # Generate client config
    log_info "Generating client configuration..."
    local server_public=$(cat "$WG_CONFIG_DIR/server_public.key")
    local server_endpoint=$(curl -s ifconfig.me || echo "YOUR_VPS_IP")
    
    # Handle SSH key configuration based on type
    if [ "$reg_type" = "provider" ]; then
        # For providers: Get VPS root SSH public key (so VPS can SSH to provider)
        log_info "Configuring provider access (VPS -> provider)..."
        local vps_ssh_pubkey=""
        if [ -f /root/.ssh/id_rsa.pub ]; then
            vps_ssh_pubkey=$(cat /root/.ssh/id_rsa.pub)
        elif [ -f /root/.ssh/id_ed25519.pub ]; then
            vps_ssh_pubkey=$(cat /root/.ssh/id_ed25519.pub)
        else
            # Generate SSH key for VPS if it doesn't exist
            log_info "Generating SSH keypair for VPS root..."
            ssh-keygen -t ed25519 -f /root/.ssh/id_ed25519 -N "" -C "root@vps-connector"
            vps_ssh_pubkey=$(cat /root/.ssh/id_ed25519.pub)
        fi

        # Create config with VPS SSH key for provider to add
        cat > "$REGISTRY_DIR/configs/${machine_id}.conf" <<EOF
[Interface]
Address = $client_ip/32
PrivateKey = PLACEHOLDER_PRIVATE_KEY

[Peer]
PublicKey = $server_public
Endpoint = ${server_endpoint}:${WG_PORT}
AllowedIPs = ${WG_SUBNET}
PersistentKeepalive = 25

# VPS SSH Public Key (add this to ~/.ssh/authorized_keys on provider)
# VPS_SSH_KEY=$vps_ssh_pubkey
EOF
    else
        # For consumers: Add consumer SSH key to VPS authorized_keys
        log_info "Configuring consumer access (consumer -> VPS)..."
        mkdir -p /root/.ssh
        chmod 700 /root/.ssh
        touch /root/.ssh/authorized_keys
        chmod 600 /root/.ssh/authorized_keys
        
        # Add consumer key to VPS if not already present
        if ! grep -q -F "$ssh_pubkey" /root/.ssh/authorized_keys 2>/dev/null; then
            echo "$ssh_pubkey" >> /root/.ssh/authorized_keys
            log_success "Consumer SSH key added to VPS authorized_keys"
        else
            log_info "Consumer SSH key already in VPS authorized_keys"
        fi

        # Create config without VPS SSH key (consumer doesn't accept SSH)
        cat > "$REGISTRY_DIR/configs/${machine_id}.conf" <<EOF
[Interface]
Address = $client_ip/32
PrivateKey = PLACEHOLDER_PRIVATE_KEY

[Peer]
PublicKey = $server_public
Endpoint = ${server_endpoint}:${WG_PORT}
AllowedIPs = ${WG_SUBNET}
PersistentKeepalive = 25
EOF
    fi

    chmod 644 "$REGISTRY_DIR/configs/${machine_id}.conf"

    # Create approval record
    local approved_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    jq --arg ip "$client_ip" \
       --arg approved "$approved_at" \
       '. + {wg_ip: $ip, approved_at: $approved}' \
       "$reg_file" > "$REGISTRY_DIR/approved/${machine_id}.json"

    # Move from pending to approved
    rm "$reg_file"
    log_success "Machine approved and moved to approved registry"

    echo
    echo "=================================================="
    echo "Approval Complete!"
    echo
    echo "  Machine ID: $machine_id"
    echo "  Type: $reg_type"
    echo "  Hostname: $hostname"
    echo "  Username: $username"
    echo "  Assigned IP: $client_ip"
    echo
    echo "Client Instructions:"
    echo "  Have the client run: ./connector finalize $reg_type $machine_id"
    echo
    if [ "$reg_type" = "provider" ]; then
        echo "After finalization, SSH access from VPS:"
        echo "  ssh $username@$client_ip"
    else
        echo "After finalization, consumer can SSH to VPS:"
        echo "  ssh root@<vps-public-ip>"
        echo "  Then SSH to any provider: ssh <user>@<provider-ip>"
    fi
    echo "=================================================="
}

# Helper function: Finalize provider setup (with SSH hardening)
finalize_provider() {
    local token="$1"
    local assigned_ip="$2"
    local vps_endpoint="$3"
    
    # Setup SSH authorized_keys for VPS to connect
    log_info "Configuring SSH access from VPS..."
    
    # Extract VPS SSH public key from config file (need sudo to read)
    local vps_ssh_key=$(sudo grep "^# VPS_SSH_KEY=" "$WG_CONFIG_DIR/$WG_INTERFACE.conf" 2>/dev/null | sed 's/^# VPS_SSH_KEY=//')
    
    if [ -n "$vps_ssh_key" ]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        
        # Add VPS public key to authorized_keys if not already present
        if [ ! -f "$HOME/.ssh/authorized_keys" ] || ! grep -q -F "$vps_ssh_key" "$HOME/.ssh/authorized_keys" 2>/dev/null; then
            echo "$vps_ssh_key" >> "$HOME/.ssh/authorized_keys"
            chmod 600 "$HOME/.ssh/authorized_keys"
            log_success "VPS SSH key added to authorized_keys"
            log_info "VPS can now SSH as: $(whoami)@<provider-ip>"
        else
            log_info "VPS SSH key already in authorized_keys"
        fi
    else
        log_error "Could not find VPS SSH key in configuration"
        log_error "VPS will not be able to SSH to this machine without password"
        log_warn "Manual fix: On VPS run: cat /root/.ssh/id_ed25519.pub"
        log_warn "Then add that key to ~/.ssh/authorized_keys on this provider machine"
    fi
    
    # Harden SSH configuration
    log_info "Hardening SSH configuration..."
    
    # Backup sshd_config if not already backed up
    if [ ! -f /etc/ssh/sshd_config.backup ]; then
        sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
    fi
    
    # Remove any existing WSL connector hardening
    sudo sed -i '/# WSL connector security hardening/,/^$/d' /etc/ssh/sshd_config
    
    # Add hardened configuration for current user
    sudo bash -c "cat >> /etc/ssh/sshd_config" <<EOF

# WSL connector security hardening
Match User $(whoami) Address 10.0.0.0/24
    PasswordAuthentication no
    PubkeyAuthentication yes
    PermitRootLogin no
EOF
    
    # Test SSH configuration
    if sudo sshd -t; then
        log_success "SSH hardened: only accessible via WireGuard with key authentication"
    else
        log_error "SSH configuration has errors. Restoring backup..."
        sudo cp /etc/ssh/sshd_config.backup /etc/ssh/sshd_config
        exit 1
    fi
    
    # Note: We rely on SSH Match rules rather than firewall DROP rules
    # to avoid accidentally locking users out if WireGuard goes down
    log_info "SSH is now restricted to WireGuard network access only"

    # Enable systemd in WSL
    log_info "Configuring WSL systemd..."
    if [ ! -f /etc/wsl.conf ] || ! grep -q "systemd=true" /etc/wsl.conf; then
        sudo bash -c 'cat > /etc/wsl.conf' <<'EOF'
[boot]
systemd=true

[network]
generateResolvConf = true
EOF
        log_warn "WSL systemd enabled. You need to restart WSL: run 'wsl --shutdown' in Windows"
        log_warn "After restarting WSL, run this command again to complete setup"
        exit 0
    fi
    
    # Enable SSH service
    log_info "Enabling SSH service..."
    sudo systemctl enable sshd 2>&1 || log_warn "Could not enable SSH service"
    
    log_info "Starting SSH..."
    if ! timeout 5 sudo systemctl start sshd 2>&1; then
        log_warn "SSH failed to start or timed out"
    else
        log_success "SSH started"
    fi
    
    # Restart SSH to apply hardening rules
    log_info "Restarting SSH to apply security hardening..."
    if sudo systemctl restart sshd 2>&1; then
        log_success "SSH restarted with hardened configuration"
    else
        log_warn "Could not restart SSH. Hardening rules may not be active."
    fi
    
    echo
    echo "=================================================="
    echo "Provider Setup Complete!"
    echo
    echo "  Machine ID: $token"
    echo "  WireGuard IP: $assigned_ip"
    echo "  VPS WireGuard IP: $VPS_WG_IP"
    echo "  VPS Public IP: $vps_endpoint"
    echo
    echo "Connection Status:"
    sudo wg show "$WG_INTERFACE" 2>/dev/null || log_warn "WireGuard not running"
    echo
    echo "Security Status:"
    echo "  - SSH restricted to WireGuard network (10.0.0.0/24)"
    echo "  - Password authentication disabled"
    echo "  - Key-based authentication only"
    echo "  - Root login disabled"
    echo
    echo "SSH Access:"
    echo "  From VPS directly:"
    echo "    ssh $(whoami)@$assigned_ip"
    echo
    echo "  From your main machine (through VPS):"
    echo "    ssh -J root@$vps_endpoint $(whoami)@$assigned_ip"
    echo
    # Get hostname safely
    local wsl_hostname=$(cat /etc/hostname 2>/dev/null || echo "wsl")
    
    echo "  Or add to ~/.ssh/config on main machine:"
    echo "    Host wsl-$wsl_hostname"
    echo "      HostName $assigned_ip"
    echo "      User $(whoami)"
    echo "      ProxyJump root@$vps_endpoint"
    echo
    echo "  Check status: ./connector status"
    echo "=================================================="
}

# Helper function: Finalize consumer setup (without SSH hardening)
finalize_consumer() {
    local token="$1"
    local assigned_ip="$2"
    local vps_endpoint="$3"
    
    log_info "Consumer setup - skipping SSH configuration (not needed)"
    
    echo
    echo "=================================================="
    echo "Consumer Setup Complete!"
    echo
    echo "  Machine ID: $token"
    echo "  WireGuard IP: $assigned_ip"
    echo "  VPS WireGuard IP: $VPS_WG_IP"
    echo "  VPS Public IP: $vps_endpoint"
    echo
    echo "Connection Status:"
    sudo wg show "$WG_INTERFACE" 2>/dev/null || log_warn "WireGuard not running"
    echo
    echo "SSH Access to VPS:"
    echo "  ssh root@$vps_endpoint"
    echo
    echo "  Then from VPS, SSH to any provider machine:"
    echo "  ssh <user>@<provider-ip>"
    echo
    echo "  Check WireGuard status: sudo wg show"
    echo "=================================================="
}

# FINALIZE: Complete setup after approval
cmd_finalize() {
    local fin_type=""
    local token=""
    local vps_ip=""
    local staging_password=""
    local ssh_port="22"
    
    # First argument must be type
    if [ -z "$1" ]; then
        log_error "Usage: connector finalize <provider|consumer> <token> [staging-password] [-p|--port <port>]"
        log_error "Example: connector finalize provider wsl-abc12345 -p 2222"
        log_error "Example: connector finalize consumer wsl-xyz78910 -p 2222"
        exit 1
    fi
    
    fin_type="$1"
    shift
    
    # Validate type
    if [ "$fin_type" != "provider" ] && [ "$fin_type" != "consumer" ]; then
        log_error "Invalid finalization type: $fin_type"
        log_error "Type must be either 'provider' or 'consumer'"
        log_error "Usage: connector finalize <provider|consumer> <token> [staging-password] [-p|--port <port>]"
        exit 1
    fi
    
    # Parse remaining arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--port)
                ssh_port="$2"
                shift 2
                ;;
            *)
                if [ -z "$token" ]; then
                    token="$1"
                elif [ -z "$staging_password" ]; then
                    staging_password="$1"
                fi
                shift
                ;;
        esac
    done

    # Try to read token from saved state if not provided
    if [ -z "$token" ] && [ -f "$WSL_CONNECTOR_DIR/machine-id" ]; then
        token=$(cat "$WSL_CONNECTOR_DIR/machine-id")
        log_info "Using saved machine ID: $token"
    fi

    if [ -z "$token" ]; then
        log_error "Usage: connector finalize <provider|consumer> <token> [staging-password] [-p|--port <port>]"
        log_error "Example: connector finalize provider wsl-abc12345"
        exit 1
    fi

    log_info "Finalizing $fin_type setup for machine: $token"

    # Read VPS IP from registration
    if [ ! -f "$WSL_CONNECTOR_DIR/registration.json" ]; then
        log_error "Registration file not found. Run 'connector register' first."
        exit 1
    fi

    # Try to load VPS connection info from saved state
    if [ -f "$WSL_CONNECTOR_DIR/vps-info" ]; then
        source "$WSL_CONNECTOR_DIR/vps-info"
        if [ -z "$vps_ip" ]; then
            vps_ip="$VPS_IP"
        fi
        if [ "$ssh_port" = "22" ] && [ -n "$SSH_PORT" ]; then
            ssh_port="$SSH_PORT"
        fi
        log_info "Using saved VPS info: $vps_ip:$ssh_port"
    fi

    # Prompt for missing info
    if [ -z "$vps_ip" ]; then
        read -p "Enter VPS IP: " vps_ip
    fi

    # Download WireGuard config
    log_info "Downloading WireGuard configuration from $vps_ip:$ssh_port..."
    local temp_config="/tmp/${token}-wg.conf"
    
    # Check if sshpass is available
    if command -v sshpass &> /dev/null; then
        # Prompt for staging password if not provided and sshpass is available
        if [ -z "$staging_password" ]; then
            read -sp "Enter staging user password: " staging_password
            echo
        fi
        
        log_info "Using sshpass for authentication..."
        local scp_output
        if ! scp_output=$(sshpass -p "$staging_password" scp -P "$ssh_port" -o StrictHostKeyChecking=no -o ConnectTimeout=10 "${STAGING_USER}@${vps_ip}:${REGISTRY_DIR}/configs/${token}.conf" "$temp_config" 2>&1); then
            log_error "Download failed. Error details:"
            echo "$scp_output" >&2
            log_error "Ensure machine has been approved by admin."
            log_error "Check VPS IP ($vps_ip) and port ($ssh_port) are correct."
            exit 1
        fi
    else
        # Fallback to interactive SCP
        log_info "sshpass not installed. Using interactive SCP..."
        log_info "You will be prompted for the staging user password."
        
        local scp_output
        if ! scp_output=$(scp -P "$ssh_port" -o StrictHostKeyChecking=no -o ConnectTimeout=10 "${STAGING_USER}@${vps_ip}:${REGISTRY_DIR}/configs/${token}.conf" "$temp_config" 2>&1); then
            log_error "Download failed. Error details:"
            echo "$scp_output" >&2
            log_error "Ensure machine has been approved by admin."
            log_error "Check VPS IP ($vps_ip) and port ($ssh_port) are correct."
            exit 1
        fi
    fi

    # Replace placeholder with actual private key
    local wg_private=$(cat "$WSL_CONNECTOR_DIR/wg-private-key")
    sed "s|PLACEHOLDER_PRIVATE_KEY|$wg_private|g" "$temp_config" > "${temp_config}.final"

    # Install WireGuard config
    log_info "Installing WireGuard configuration..."
    sudo mkdir -p "$WG_CONFIG_DIR"
    sudo mv "${temp_config}.final" "$WG_CONFIG_DIR/$WG_INTERFACE.conf"
    sudo chmod 600 "$WG_CONFIG_DIR/$WG_INTERFACE.conf"
    rm -f "$temp_config"

    # Verify the IP in the config before starting
    local config_ip=$(sudo grep "^Address" "$WG_CONFIG_DIR/$WG_INTERFACE.conf" | awk '{print $3}' | cut -d'/' -f1)
    log_info "Configured WireGuard IP: $config_ip"
    
    # Enable and start WireGuard service
    log_info "Enabling WireGuard service..."
    sudo systemctl enable wg-quick@$WG_INTERFACE 2>&1 || log_warn "Could not enable WireGuard service"
    
    log_info "Starting WireGuard..."
    if ! timeout 10 sudo systemctl start wg-quick@$WG_INTERFACE 2>&1; then
        log_warn "WireGuard failed to start or timed out. Check logs with: sudo journalctl -u wg-quick@wg0"
        log_warn "You may need to start it manually: sudo systemctl start wg-quick@wg0"
    else
        log_success "WireGuard started"
    fi

    # Extract assigned IP from config
    local assigned_ip=$(sudo grep "^Address" "$WG_CONFIG_DIR/$WG_INTERFACE.conf" | awk '{print $3}' | cut -d'/' -f1)

    # Verify the actual IP assigned
    log_info "Verifying WireGuard interface..."
    sleep 2
    local actual_ip=$(ip addr show wg0 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
    if [ -n "$actual_ip" ]; then
        log_success "WireGuard interface has IP: $actual_ip"
        if [ "$actual_ip" != "$assigned_ip" ]; then
            log_warn "WARNING: IP mismatch detected!"
            log_warn "  Expected: $assigned_ip"
            log_warn "  Actual: $actual_ip"
            log_warn "  The VPS may have a different IP in its config. Contact admin to verify."
        fi
    else
        log_warn "Could not detect WireGuard IP address"
    fi
    
    # Test connectivity
    log_info "Testing VPS connectivity..."
    if sudo wg show | grep -q "latest handshake"; then
        log_success "WireGuard tunnel established!"
    else
        log_warn "WireGuard tunnel not yet established (may take a moment)"
    fi

    if ping -c 1 -W 2 "$VPS_WG_IP" &>/dev/null; then
        log_success "VPS is reachable via WireGuard!"
    else
        log_warn "Cannot ping VPS yet (may need to wait for handshake)"
    fi

    # Get VPS public endpoint from config
    local vps_endpoint=$(sudo grep "^Endpoint" "$WG_CONFIG_DIR/$WG_INTERFACE.conf" | awk '{print $3}' | cut -d':' -f1)
    
    # Call type-specific finalize helper
    if [ "$fin_type" = "provider" ]; then
        finalize_provider "$token" "$assigned_ip" "$vps_endpoint"
    else
        finalize_consumer "$token" "$assigned_ip" "$vps_endpoint"
    fi
}

# LIST: List all approved machines
cmd_list() {
    require_root

    if ! is_vps; then
        log_error "This command must be run on the VPS"
        exit 1
    fi

    require_package jq

    log_info "Approved Machines:"
    echo
    printf "%-15s %-18s %-20s %-12s %-15s %-10s\n" "MACHINE ID" "TYPE" "HOSTNAME" "USER" "IP ADDRESS" "STATUS"
    printf "%-15s %-18s %-20s %-12s %-15s %-10s\n" "----------" "----" "--------" "----" "----------" "------"

    for file in "$REGISTRY_DIR/approved"/*.json; do
        [ -f "$file" ] || continue
        
        local machine_id=$(basename "$file" .json)
        local hostname=$(jq -r '.hostname' "$file")
        local username=$(jq -r '.username' "$file")
        local ip=$(jq -r '.wg_ip' "$file")
        local pubkey=$(jq -r '.wg_pubkey' "$file")
        local reg_type=$(jq -r '.type // "provider"' "$file")
        
        # Convert type to display label
        local type_label="COMPUTE PROVIDER"
        if [ "$reg_type" = "consumer" ]; then
            type_label="COMPUTE CONSUMER"
        fi
        
        # Get WireGuard status
        local wg_status=$(wg show "$WG_INTERFACE" | grep -A 5 "$pubkey" || echo "")
        local last_handshake="never"
        local status="offline"
        
        if echo "$wg_status" | grep -q "latest handshake"; then
            last_handshake=$(echo "$wg_status" | grep "latest handshake" | sed 's/.*latest handshake: //')
            # Check if handshake is recent (within 3 minutes)
            if echo "$last_handshake" | grep -qE "(second|minute).*ago"; then
                status="online"
            fi
        fi
        
        printf "%-15s %-18s %-20s %-12s %-15s %-10s\n" \
            "${machine_id:0:15}" \
            "${type_label:0:18}" \
            "${hostname:0:20}" \
            "${username:0:12}" \
            "$ip" \
            "$status"
    done
    echo
}

# REVOKE: Revoke machine access
cmd_revoke() {
    local machine_id="$1"
    require_root

    if ! is_vps; then
        log_error "This command must be run on the VPS"
        exit 1
    fi

    if [ -z "$machine_id" ]; then
        log_error "Usage: connector revoke <machine-id>"
        exit 1
    fi

    local approved_file="$REGISTRY_DIR/approved/${machine_id}.json"
    if [ ! -f "$approved_file" ]; then
        log_error "Machine not found in approved registry: $machine_id"
        exit 1
    fi

    log_warn "Revoking access for machine: $machine_id"
    
    # Get machine info
    local hostname=$(jq -r '.hostname' "$approved_file")
    local wg_pubkey=$(jq -r '.wg_pubkey' "$approved_file")
    local ssh_pubkey=$(jq -r '.ssh_pubkey' "$approved_file")

    # Remove from WireGuard config
    log_info "Removing WireGuard peer..."
    local temp_config="${WG_CONFIG_DIR}/${WG_INTERFACE}.conf.tmp"
    awk -v pubkey="$wg_pubkey" '
        /^\[Peer\]/ { in_peer=1; peer_content=$0"\n"; next }
        in_peer && /^PublicKey/ { 
            if ($3 == pubkey) { 
                skip_peer=1 
            }
            peer_content=peer_content$0"\n"
            next 
        }
        in_peer && /^$/ { 
            if (!skip_peer) print peer_content
            in_peer=0
            skip_peer=0
            peer_content=""
            next
        }
        in_peer { peer_content=peer_content$0"\n"; next }
        !in_peer { print }
    ' "$WG_CONFIG_DIR/$WG_INTERFACE.conf" > "$temp_config"
    
    mv "$temp_config" "$WG_CONFIG_DIR/$WG_INTERFACE.conf"
    wg syncconf "$WG_INTERFACE" <(wg-quick strip "$WG_INTERFACE")
    log_success "WireGuard peer removed"

    # Move to revoked
    mv "$approved_file" "$REGISTRY_DIR/revoked/"
    rm -f "$REGISTRY_DIR/configs/${machine_id}.conf"

    log_success "Machine revoked: $machine_id ($hostname)"
}

# STATUS: Show connection status
cmd_status() {
    log_info "WireGuard Connection Status:"
    echo

    if [ ! -f "/etc/wireguard/$WG_INTERFACE.conf" ]; then
        log_error "WireGuard not configured. Run 'connector register' and 'connector finalize' first."
        exit 1
    fi

    # Show WireGuard status
    if sudo systemctl is-active --quiet wg-quick@$WG_INTERFACE; then
        log_success "WireGuard service is running"
    else
        log_error "WireGuard service is not running"
        echo "  Start with: sudo systemctl start wg-quick@$WG_INTERFACE"
    fi

    # Show assigned IP
    local assigned_ip=$(sudo grep "^Address" "$WG_CONFIG_DIR/$WG_INTERFACE.conf" 2>/dev/null | awk '{print $3}')
    if [ -n "$assigned_ip" ]; then
        echo "  Assigned IP: $assigned_ip"
    else
        echo "  Assigned IP: (unable to read config)"
    fi

    # Show WireGuard details
    echo
    sudo wg show "$WG_INTERFACE" 2>/dev/null || log_warn "Cannot retrieve WireGuard stats"

    # Test VPS connectivity
    echo
    log_info "Testing VPS connectivity..."
    if ping -c 1 -W 2 "$VPS_WG_IP" &>/dev/null; then
        log_success "VPS is reachable at $VPS_WG_IP"
    else
        log_error "Cannot reach VPS at $VPS_WG_IP"
    fi

    # Show SSH status
    echo
    if sudo systemctl is-active --quiet sshd; then
        log_success "SSH service is running"
    else
        log_warn "SSH service is not running"
        echo "  Start with: sudo systemctl start sshd"
    fi
}

# HOP: Connect to WSL machine through VPS
cmd_hop() {
    local vps_host="$1"
    local target="$2"
    
    if [ -z "$vps_host" ]; then
        echo "Usage: connector hop <vps-host> [user@ip|machine-id]"
        echo
        echo "Examples:"
        echo "  connector hop root@203.0.113.1                   # List available machines"
        echo "  connector hop root@203.0.113.1 kipras@10.0.0.2  # Connect by user@ip"
        echo "  connector hop root@203.0.113.1 wsl-abc12345     # Connect by machine ID"
        exit 1
    fi
    
    # If no target specified, list available machines
    if [ -z "$target" ]; then
        log_info "Fetching available machines from $vps_host..."
        
        # Get list of approved machines from VPS
        ssh -o ConnectTimeout=10 "$vps_host" "cd /var/lib/wsl-registry/approved 2>/dev/null && ls *.json 2>/dev/null" > /tmp/hop-machines.txt 2>/dev/null || {
            log_error "Failed to connect to VPS or no approved machines found"
            log_error "Make sure you can SSH to the VPS and machines are approved"
            rm -f /tmp/hop-machines.txt
            exit 1
        }
        
        if [ ! -s /tmp/hop-machines.txt ]; then
            log_warn "No approved machines found on VPS"
            rm -f /tmp/hop-machines.txt
            exit 0
        fi
        
        echo
        echo "Available machines:"
        echo "=================="
        
        local count=0
        while read -r json_file; do
            [ -z "$json_file" ] && continue
            count=$((count + 1))
            
            # Fetch machine details
            local machine_data=$(ssh "$vps_host" "cat /var/lib/wsl-registry/approved/$json_file 2>/dev/null")
            local machine_id=$(echo "$json_file" | sed 's/.json$//')
            local hostname=$(echo "$machine_data" | jq -r '.hostname' 2>/dev/null || echo "unknown")
            local username=$(echo "$machine_data" | jq -r '.username' 2>/dev/null || echo "unknown")
            local ip=$(echo "$machine_data" | jq -r '.wg_ip' 2>/dev/null || echo "unknown")
            
            echo "$count. $username@$ip"
            echo "   Machine ID: $machine_id"
            echo "   Hostname: $hostname"
            echo "   Command: ./connector hop $vps_host $username@$ip"
            echo
        done < /tmp/hop-machines.txt
        
        rm -f /tmp/hop-machines.txt
        exit 0
    fi
    
    # Target specified - connect to it
    log_info "Connecting to $target through $vps_host..."
    
    local ssh_target=""
    
    # Check if target is in user@ip format or machine-id format
    if [[ "$target" =~ @ ]]; then
        # Already in user@ip format
        ssh_target="$target"
    else
        # It's a machine ID - fetch details from VPS
        local machine_data=$(ssh "$vps_host" "cat /var/lib/wsl-registry/approved/$target.json 2>/dev/null")
        if [ -z "$machine_data" ]; then
            log_error "Machine $target not found on VPS"
            log_error "Run './connector hop $vps_host' to see available machines"
            exit 1
        fi
        
        local username=$(echo "$machine_data" | jq -r '.username')
        local ip=$(echo "$machine_data" | jq -r '.wg_ip')
        
        if [ -z "$username" ] || [ -z "$ip" ] || [ "$username" = "null" ] || [ "$ip" = "null" ]; then
            log_error "Invalid machine data for $target"
            exit 1
        fi
        
        ssh_target="$username@$ip"
        log_info "Resolved $target to $ssh_target"
    fi
    
    # Connect using nested SSH (VPS does the authentication to WSL)
    ssh -t "$vps_host" ssh "$ssh_target"
}

# CLEANUP-WSL: Clean up WSL-side configuration
cmd_cleanup_wsl() {
    log_warn "This will remove ALL WireGuard and connector configuration on this WSL machine"
    read -p "Are you sure? [y/n]: " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        log_info "Cleanup cancelled"
        exit 0
    fi
    
    log_info "Stopping services..."
    sudo systemctl stop wg-quick@$WG_INTERFACE 2>/dev/null || true
    sudo systemctl disable wg-quick@$WG_INTERFACE 2>/dev/null || true
    
    log_info "Removing WireGuard configuration..."
    sudo rm -f "$WG_CONFIG_DIR/$WG_INTERFACE.conf"
    
    log_info "Removing connector data..."
    rm -rf "$WSL_CONNECTOR_DIR"
    
    log_info "Removing SSH keys..."
    rm -f "$HOME/.ssh/wsl-to-vps" "$HOME/.ssh/wsl-to-vps.pub"
    
    log_info "Removing SSH hardening rules..."
    if [ -f /etc/ssh/sshd_config ]; then
        sudo sed -i '/# WSL connector security hardening/,/^$/d' /etc/ssh/sshd_config
        sudo systemctl restart sshd 2>/dev/null || true
    fi
    
    log_success "WSL cleanup complete! You can now run 'connector register' again."
}

# CLEANUP-VPS: Clean up VPS-side configuration
cmd_cleanup_vps() {
    require_root
    
    if ! is_vps; then
        log_error "This command must be run on the VPS"
        exit 1
    fi
    
    log_warn "This will remove ALL machine registrations and WireGuard peer configurations"
    log_warn "The VPS WireGuard server and staging user will remain configured"
    read -p "Are you sure? [y/n]: " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        log_info "Cleanup cancelled"
        exit 0
    fi
    
    log_info "Stopping WireGuard..."
    systemctl stop wg-quick@$WG_INTERFACE 2>/dev/null || true
    
    log_info "Removing connector-managed peers from WireGuard..."
    # Only remove peers that have machine-id comments (wsl-xxxxxxxx)
    # This preserves any manually added peers
    local temp_config="${WG_CONFIG_DIR}/${WG_INTERFACE}.conf.tmp"
    awk '
        # Track if we are in a peer block
        /^# wsl-[a-z0-9]+/ { 
            skip_peer=1
            next 
        }
        # Start of new peer or interface section ends skipping
        /^(\[Peer\]|\[Interface\])/ && skip_peer {
            skip_peer=0
            if ($0 ~ /^\[Interface\]/) print
            next
        }
        # Skip lines if we are in a connector-managed peer
        skip_peer { next }
        # Print everything else
        { print }
    ' "$WG_CONFIG_DIR/$WG_INTERFACE.conf" > "$temp_config"
    
    mv "$temp_config" "$WG_CONFIG_DIR/$WG_INTERFACE.conf"
    chmod 600 "$WG_CONFIG_DIR/$WG_INTERFACE.conf"
    
    log_info "Clearing all machine registrations..."
    rm -f "$REGISTRY_DIR/pending"/*.json
    rm -f "$REGISTRY_DIR/approved"/*.json
    rm -f "$REGISTRY_DIR/configs"/*.conf
    rm -f "$REGISTRY_DIR/revoked"/*.json
    
    log_info "Starting WireGuard..."
    systemctl start wg-quick@$WG_INTERFACE
    
    log_success "VPS cleanup complete! Ready to approve new machines."
}

# HELP: Show usage information
cmd_help() {
    cat <<EOF
connector v${VERSION} - WireGuard VPS-WSL Management Tool

Usage: connector <command> [arguments]

VPS Commands (run on VPS):
  vps-init                     Initialize VPS as WireGuard server
  approve [machine-id]         Approve pending machine (provider or consumer)
  list                         List all approved machines with type
  revoke <machine-id>          Revoke machine access
  cleanup-vps                  Remove all registrations (keeps VPS config)

Machine Registration Commands:
  register <provider|consumer> <vps-ip> [-p port]
                               Register machine to VPS
                               - provider: WSL/compute machine (accepts SSH from VPS)
                               - consumer: Main machine (can SSH to VPS as root)

  finalize <provider|consumer> [token] [-p port]
                               Complete setup after approval
                               - provider: Configures SSH hardening for WSL
                               - consumer: Skips SSH setup (not needed)

  status                       Show WireGuard connection status
  cleanup-wsl                  Remove all local configuration

Client Commands (run from any machine):
  hop <vps-host> [user@ip]     Connect to provider through VPS
                               - No target: list available machines
                               - With target: connect to user@ip

General:
  help                         Show this help message

Examples:
  # On VPS (first time setup):
  sudo ./connector vps-init

  # On WSL/provider machine (register as compute provider):
  ./connector register provider 1.2.3.4
  ./connector register provider 1.2.3.4 -p 2222

  # On main/consumer machine (register as compute consumer):
  ./connector register consumer 1.2.3.4
  ./connector register consumer 1.2.3.4 -p 2222

  # On VPS (approve machine - shows type):
  sudo ./connector approve

  # On provider machine (after approval):
  ./connector finalize provider wsl-abc12345
  ./connector finalize provider wsl-abc12345 -p 2222

  # On consumer machine (after approval):
  ./connector finalize consumer wsl-xyz78910
  ./connector finalize consumer wsl-xyz78910 -p 2222

  # Check connection status:
  ./connector status

  # From consumer machine - SSH to VPS, then to any provider:
  ssh root@vps-ip
  ssh user@provider-ip

  # From any machine - list machines available through VPS:
  ./connector hop root@203.0.113.1

  # From any machine - connect to specific provider:
  ./connector hop root@203.0.113.1 kipras@10.0.0.2
  ./connector hop root@203.0.113.1 wsl-abc12345

For more information, see README.md
EOF
}

# Main dispatcher
main() {
    local cmd="${1:-help}"
    
    case "$cmd" in
        vps-init)
            cmd_vps_init "${@:2}"
            ;;
        approve)
            cmd_approve "${@:2}"
            ;;
        list)
            cmd_list "${@:2}"
            ;;
        revoke)
            cmd_revoke "${@:2}"
            ;;
        register)
            cmd_register "${@:2}"
            ;;
        finalize)
            cmd_finalize "${@:2}"
            ;;
        status)
            cmd_status "${@:2}"
            ;;
        hop)
            cmd_hop "${@:2}"
            ;;
        cleanup-wsl)
            cmd_cleanup_wsl "${@:2}"
            ;;
        cleanup-vps)
            cmd_cleanup_vps "${@:2}"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            log_error "Unknown command: $cmd"
            echo
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
